package RobotCode;

import com.qualcomm.robotcore.eventloop.opmode.Disabled;
import com.qualcomm.robotcore.hardware.CRServo;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.util.ElapsedTime;



@Autonomous(name="SPECI**MEN** Autonomous Team 2", group="Linear Opmode")


public class Team2SpecimenAuto extends LinearOpMode {

    // Declare OpMode members for each of the 4 motors.
    private ElapsedTime runtime = new ElapsedTime();
    private DcMotorEx leftFrontDrive = null;
    private DcMotorEx leftBackDrive = null;
    private DcMotorEx rightFrontDrive = null;
    private DcMotorEx rightBackDrive = null;
    private DcMotorEx slideArm = null;
    private DcMotorEx intakePivotMotor = null;
    private CRServo upperServo = null;
    private CRServo lowerServo = null;
    private DcMotorEx specMotor = null;
    private CRServo leftSpecServo = null;
    private CRServo rightSpecServo = null;
    

    // Math for wheel movement
    private final double wheelCircumference = 75*3.14;
    private final double gearReduction = 3.61*5.23;
    private final double counts = 28.0;
    
    private final double rev = counts*gearReduction;
    private final int revPerMM = (int)rev/(int)wheelCircumference;
    private final double inches = revPerMM*25.4;
    
    private DcMotorEx wheelForAutoFastMovement = null;
    private int encoderBasedOffWheelForAutoFastMovement = 0;

    // Declare OpMode members for each of the moving parts.

    @Override
    public void runOpMode() {
        
        // Initialize the hardware variables. Note that the strings used here must correspond
        // to the names assigned during the robot configuration step on the DS or RC devices.

        leftFrontDrive  = hardwareMap.get(DcMotorEx.class, "frontLeft");
        leftBackDrive  = hardwareMap.get(DcMotorEx.class, "backLeft");
        rightFrontDrive = hardwareMap.get(DcMotorEx.class, "frontRight");
        rightBackDrive = hardwareMap.get(DcMotorEx.class, "backRight");
        slideArm = hardwareMap.get(DcMotorEx.class, "slideMotor");
        upperServo = hardwareMap.get(CRServo.class, "topIntake");
        lowerServo = hardwareMap.get(CRServo.class, "bottomIntake");
        intakePivotMotor = hardwareMap.get(DcMotorEx.class, "intakePivotMotor");
        specMotor = hardwareMap.get(DcMotorEx.class, "specMotor");
        leftSpecServo = hardwareMap.get(CRServo.class, "leftSpecServo");
        rightSpecServo = hardwareMap.get(CRServo.class, "rightSpecServo");

        // Set Directions
        
        // leftFrontDrive.setDirection(DcMotor.Direction.REVERSE);
        // leftBackDrive.setDirection(DcMotor.Direction.REVERSE);
        // rightFrontDrive.setDirection(DcMotor.Direction.REVERSE);
        rightBackDrive.setDirection(DcMotor.Direction.REVERSE);
        intakePivotMotor.setDirection(DcMotor.Direction.REVERSE);
        
        slideArm.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        specMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);

        // Wait for the game to start (driver presses PLAY)
        telemetry.addData("Status", "Initialized");
        telemetry.update();
        int count=0;
        waitForStart();
        runtime.reset();
        // run until the end of the match (driver presses STOP)
        while (opModeIsActive()&&count==0) {
            // Gallop on Rocinante!!!
            //observation();
            observation();
            
            count++;
        }
    }
    public void input(double leftFront, double rightFront, double leftBack, double rightBack)
    {
        leftFrontDrive.setPower(leftFront);
        rightFrontDrive.setPower(rightFront);
        leftBackDrive.setPower(leftBack);
        rightBackDrive.setPower(rightBack);
        sleep(500);
    }
    public void turnLeft(int angle)
    {
        int convert=revPerMM*angle*(38/10)+(angle*12/10); //
        turnEncoders(-convert, convert, -convert, convert);
    }
    public void turnRight(int angle)
    {
        int convert=revPerMM*angle*(38/10)+(angle*12/10);
        turnEncoders(convert, -convert, convert, -convert);
    }
    public void driveEncoders(int target)
    {
        encoders(target, target, target, target);
    }
    public void backEncoders(int target)
    {
        encoders(-target, -target, -target, -target);
    }
    public void rightEncoders(int target)
    {
        encoders(target, -target, -target, target);
    }
    public void leftEncoders(int target)
    {
        encoders(-target, target, target, -target);
    }
    public void leftTopDiagonal(int target)
    {
        encoders(0, target, target, 0);
    }
    public void rightTopDiagonal(int target)
    {
        encoders(target, 0, 0, target);
    }
    public void leftBottomDiagonal(int target)
    {
        encoders(-target, 0, 0, -target);
    }
    public void rightBottomDiagonal(int target)
    {
        encoders(0, -target, -target, 0);
    }

    // Encoders is a function that makes the four wheels move in a direction by the distance inputted. (100, 100, 0, 0) would make lF and rF go 100mm forwards.
    // The rest of the movement functions rely on this!!!

    public void encoders(int leftFront, int rightFront, int leftBack, int rightBack)
    {
        leftFrontDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        rightFrontDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        leftBackDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        rightBackDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        
        leftFrontDrive.setTargetPosition(leftFront*revPerMM);
        rightFrontDrive.setTargetPosition(rightFront*revPerMM);
        leftBackDrive.setTargetPosition(leftBack*revPerMM);
        rightBackDrive.setTargetPosition(rightBack*revPerMM);
        
        leftFrontDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        rightFrontDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        leftBackDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        rightBackDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        
        double power=0.2;
        
        leftFrontDrive.setVelocity(1500);
        rightFrontDrive.setVelocity(1500);
        leftBackDrive.setVelocity(1500);
        rightBackDrive.setVelocity(1500);
        
        if(leftFront != 0){
            wheelForAutoFastMovement = leftFrontDrive;
        } else if(leftBack != 0){
            wheelForAutoFastMovement = leftBackDrive;
        } else if(rightFront != 0){
            wheelForAutoFastMovement = rightFrontDrive;
        } else if(rightBack != 0){
            wheelForAutoFastMovement = rightBackDrive;
        } else {
            // dumbass
            // you fucking suck this shouldn't happen
            // I HATE YOU SOFTWARE TEAM I HATE YOU YOU TOO NEW SOFTWARE TEAM - Sehwan homeless man
            wheelForAutoFastMovement = slideArm;
            // this is to specifically fuck with you useless member
        }
        
        if(wheelForAutoFastMovement == leftFrontDrive){
            encoderBasedOffWheelForAutoFastMovement = leftFront;
        } else if (wheelForAutoFastMovement == leftBackDrive){
            encoderBasedOffWheelForAutoFastMovement = leftBack;
        } else if (wheelForAutoFastMovement == rightFrontDrive){
            encoderBasedOffWheelForAutoFastMovement = rightFront;
        } else if (wheelForAutoFastMovement == rightBackDrive){
            encoderBasedOffWheelForAutoFastMovement = rightBack;
        }
        
        // while ((wheelForAutoFastMovement.getCurrentPosition()) < Math.abs(encoderBasedOffWheelForAutoFastMovement - 10) )
        // {
        // }
        
        // while (opModeIsActive()&&leftFrontDrive.isBusy()||rightFrontDrive.isBusy()||leftBackDrive.isBusy()||rightBackDrive.isBusy())
        // {
        //     telemetry.addData("wheelForAutoFastMovementwheelForAutoFastMovement", wheelForAutoFastMovement.getCurrentPosition());
        //     telemetry.update();
        //     sleep(30);
        // }
        
        while (opModeIsActive() && Math.abs(wheelForAutoFastMovement.getCurrentPosition()) < ( Math.abs(wheelForAutoFastMovement.getTargetPosition())-10)){
            telemetry.addData("wheelPos", Math.abs(wheelForAutoFastMovement.getCurrentPosition()));
            telemetry.addData("goalPos", ( Math.abs(encoderBasedOffWheelForAutoFastMovement)-10));
            telemetry.addData("diffPos", (Math.abs(encoderBasedOffWheelForAutoFastMovement)-10) - Math.abs(wheelForAutoFastMovement.getCurrentPosition()));
            telemetry.update();
        }
        
        sleep(100);
        
        // sleep( (((Math.abs(leftFront)) /  (400+Math.round(Math.abs(leftFront*0.10)))  ) * 1000) + 800);
        
        
        
        leftFrontDrive.setPower(0);
        rightFrontDrive.setPower(0);
        leftBackDrive.setPower(0);
        rightBackDrive.setPower(0);
    }
    
    public void turnEncoders(int leftFront, int rightFront, int leftBack, int rightBack)
    {
        leftFrontDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        rightFrontDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        leftBackDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        rightBackDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        
        leftFrontDrive.setTargetPosition(leftFront*revPerMM);
        rightFrontDrive.setTargetPosition(rightFront*revPerMM);
        leftBackDrive.setTargetPosition(leftBack*revPerMM);
        rightBackDrive.setTargetPosition(rightBack*revPerMM);
        
        leftFrontDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        rightFrontDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        leftBackDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        rightBackDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        
        double power=0.2;
        
        leftFrontDrive.setVelocity(3000);
        rightFrontDrive.setVelocity(3000);
        leftBackDrive.setVelocity(3000);
        rightBackDrive.setVelocity(3000);
        
        
        while (opModeIsActive()&&leftFrontDrive.isBusy()||rightFrontDrive.isBusy()||leftBackDrive.isBusy()||rightBackDrive.isBusy())
        {
        }
        
        leftFrontDrive.setPower(0);
        rightFrontDrive.setPower(0);
        leftBackDrive.setPower(0);
        rightBackDrive.setPower(0);
    }

    public void linearSlideEncoders(int goalPos)
    {
        slideArm.setTargetPosition(goalPos);
        slideArm.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        
        double power=0.2;
        
        slideArm.setVelocity(1500);
        
        
        while (opModeIsActive()&&slideArm.isBusy())
        {
            // telemetry.addData("I will rape Nav", "If you wanted me to live");
            // sleep(50);
        }
        
        // telemetry.addData("I will rape Nav", "If you wanted me to speak");
        
        slideArm.setPower(0.0);
    }
    
    public void specSlideEncoders(int goalPos)
    {
        specMotor.setTargetPosition(goalPos);
        specMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        
        double power=0.2;
        
        specMotor.setVelocity(1500);
        
        
        while (opModeIsActive() && Math.abs(specMotor.getCurrentPosition()) < ( Math.abs(specMotor.getTargetPosition())-10)){

        }
        
        specMotor.setPower(0.0);

        
    }
    
    public void specIntake(String state){
        if(state == "Intake"){
            leftSpecServo.setPower(-1.0);
            rightSpecServo.setPower(1.0);
        } else if(state == "Outtake") {
            leftSpecServo.setPower(1.0);
            rightSpecServo.setPower(-1.0);
        } else {
            leftSpecServo.setPower(0.0);
            rightSpecServo.setPower(0.0);
        }
    }

    public void intakeEncoders(String state)
    {
        if(state == "In"){
            upperServo.setPower(1.0);
            lowerServo.setPower(-1.0);
        } else if(state == "Out"){
            upperServo.setPower(-1.0);
            lowerServo.setPower(1.0);
        } else if(state == "Stop"){
            upperServo.setPower(0.0);
            lowerServo.setPower(0.0);
        }
    }

    public void intakePivotEncoders(String states)
    {
        if(states == "Up"){
            intakePivotMotor.setPower(-0.7);
        } else if (states == "Down"){
            intakePivotMotor.setPower(0.5);
        } else if (states == "Hold"){
            intakePivotMotor.setPower(-0.2);
        }
    }

    public void observation()
    {
        rightEncoders(300);   
        backEncoders(650);
        
        // score here, arm down via power while moving
        specSlideEncoders(-4300);
        specIntake("Outtake");
        specSlideEncoders(-3000);
        specIntake("Hold"); //frankly call this whatevs
        
        driveEncoders(100); //front - 50 = 550
        leftEncoders(1500);
        turnRight(180);
        backEncoders(500);
        
        // grab
        
        leftEncoders(1500);
        driveEncoders(100);
        turnRight(180);
        backEncoders(540);
        
        // score again
        
        specSlideEncoders(-4300);
        specIntake("Outtake");
        specSlideEncoders(-3000);
        specIntake("Hold"); //frankly call this whatevs
        
        driveEncoders(100);
        leftEncoders(500);
        leftTopDiagonal(900);
    }

}
